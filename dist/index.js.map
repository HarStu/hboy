{
  "version": 3,
  "sources": ["../src/mem.ts", "../src/cpu.ts", "../src/disasm.ts", "../src/gb.ts", "../src/index.ts"],
  "sourcesContent": [
    "/**\n * Models the GameBoy's Memory Map\n */\n\nimport { Address, UInt8, UInt16 } from './types.js';\n\nexport class Mem {\n  private readonly romBanks: Uint8Array[]; // ROM banks (Bank 0 fixed, others switchable)\n  private crb: number; // Current ROM bank. Set to 1 by default (0 contains the 0x0000-0x3FFF fixed ROM bank)\n  private readonly vram: Uint8Array; // 8KB Video RAM, located 0x8000-0x9FFF\n  private readonly eramBanks: Uint8Array[]; // External RAM banks\n  private cerb: number; // Current eram bank. Defaults to -1 (no eram banks on cart)\n  private readonly wram: Uint8Array; // 8KB Work RAM, located 0xC000-0xDFFF\n  private readonly oam: Uint8Array; // Object Attribute Memory\n  private readonly io: Uint8Array; // I/O Registers\n  private readonly hram: Uint8Array; // High RAM\n  private readonly ie: Uint8Array; // Interrupt Enable Register\n\n  constructor(ROM?: Uint8Array) {\n    this.romBanks = []; // ROM banks (Bank 0 fixed, others switchable)\n    this.romBanks[0] = new Uint8Array(0x4000); // 16KB initial fixed ROM bank\n\n    this.crb = 1; // Current ROM bank. Set to 1 by default (0 contains the 0x0000-0x3FFF fixed ROM bank)\n\n    this.vram = new Uint8Array(0x2000); // 8KB Video RAM, located 0x8000-0x9FFF\n\n    this.eramBanks = []; // External RAM banks\n    this.cerb = -1; // Current eram bank. Defaults to -1 (no eram banks on cart)\n\n    this.wram = new Uint8Array(0x2000); // 8KB Work RAM, located 0xC000-0xDFFF\n    this.oam = new Uint8Array(0x9F); // Object Attribute Memory\n    this.io = new Uint8Array(0x7F); // I/O Registers\n    this.hram = new Uint8Array(0x7E); // High RAM\n    this.ie = new Uint8Array(0x1); // Interrupt Enable Register\n\n    // TODO -- POPULATE BANK ARRAYS WITH APPROPRIATE MEMORY BASED ON CARTRIDGE MBC\n    if (ROM) {\n      // Load ROM data if provided\n      const romSize = Math.min(ROM.length, 0x4000);\n      this.romBanks[0]!.set(ROM.subarray(0, romSize));\n    }\n  }\n\n  readByte(addr: Address): UInt8 {\n    if (addr >= 0x0000 && addr < 0x4000) {\n      // Return from first fixed ROM bank\n      const bank = this.romBanks[0];\n      if (!bank) {\n        throw new Error('ROM bank 0 not initialized');\n      }\n      const value = bank[addr];\n      return value ?? 0xFF;\n    } else if (addr >= 0x4000 && addr < 0x8000) {\n      // Return from switchable ROM bank\n      const bank = this.romBanks[this.crb];\n      if (!bank) {\n        console.log(`WARN in Mem.readByte: ROM bank ${this.crb} not available`);\n        return 0xFF;\n      }\n      const value = bank[addr - 0x4000];\n      return value ?? 0xFF;\n    } else if (addr >= 0x8000 && addr < 0xA000) {\n      // Return from vram\n      const value = this.vram[addr - 0x8000];\n      return value ?? 0xFF;\n    } else if (addr >= 0xA000 && addr < 0xC000) {\n      // Return from the switchable external RAM bank (if available)\n      if (this.cerb !== -1) {\n        const bank = this.eramBanks[this.cerb];\n        if (!bank) {\n          console.log(`WARN in Mem.readByte: External RAM bank ${this.cerb} not available`);\n          return 0xFF;\n        }\n        const value = bank[addr - 0xA000];\n        return value ?? 0xFF;\n      } else {\n        console.log(`WARN in Mem.readByte: Attempt to load from non-existent external RAM bank at ${addr.toString(16)}`);\n        return 0xFF;\n      }\n    } else if (addr >= 0xC000 && addr < 0xE000) {\n      // Return from work RAM\n      const value = this.wram[addr - 0xC000];\n      return value ?? 0xFF;\n    } else if (addr >= 0xE000 && addr < 0xFE00) {\n      // Return from Echo RAM\n      console.log(`WARN in Mem.readByte: Loaded from 'Echo Ram' at addr ${addr.toString(16)}`);\n      const value = this.wram[addr - 0xE000];\n      return value ?? 0xFF;\n    } else if (addr >= 0xFE00 && addr < 0xFEA0) {\n      // Return from Object Attribute Memory\n      const value = this.oam[addr - 0xFE00];\n      return value ?? 0xFF;\n    } else if (addr >= 0xFEA0 && addr < 0xFF00) {\n      // (Attempt to) return from Unusable Memory\n      console.log(`Error in Mem.readByte: Attempt to load unusable memory at addr ${addr.toString(16)}`);\n      return 0xFF;\n    } else if (addr >= 0xFF00 && addr < 0xFF80) {\n      // Return from I/O Registers\n      const value = this.io[addr - 0xFF00];\n      return value ?? 0xFF;\n    } else if (addr >= 0xFF80 && addr < 0xFFFF) {\n      // Return from High RAM\n      const value = this.hram[addr - 0xFF80];\n      return value ?? 0xFF;\n    } else if (addr === 0xFFFF) {\n      // Return Interrupt Enable Register\n      const value = this.ie[0];\n      return value ?? 0xFF;\n    } else {\n      console.log(`Error in Mem.readByte: Attempt to load from outside memory map at ${addr.toString(16)}`);\n      return 0xFF;\n    }\n  }\n\n  writeByte(addr: Address, val: UInt8): void {\n    if (val < 0x00 || val > 0xFF) {\n      console.log(`ERROR in Mem.writeByte: Attempt to write non-byte val ${val}`);\n      return;\n    }\n\n    if (addr >= 0x0000 && addr < 0x4000) {\n      // TODO -- Fixed ROM bank\n      console.log(`TODO in Mem.writeByte: Attempt to write to Fixed ROM bank at ${addr.toString(16)}`);\n    } else if (addr >= 0x4000 && addr < 0x8000) {\n      // TODO -- Switchable ROM bank\n      console.log(`TODO in Mem.writeByte: Attempt to write to Switchable ROM bank at ${addr.toString(16)}`);\n    } else if (addr >= 0x8000 && addr < 0xA000) {\n      // Write to vram\n      const offset = addr - 0x8000;\n      if (offset < this.vram.length) {\n        this.vram[offset] = val;\n      }\n    } else if (addr >= 0xA000 && addr < 0xC000) {\n      // Write to switchable external RAM bank (if available)\n      if (this.cerb !== -1) {\n        const bank = this.eramBanks[this.cerb];\n        if (bank) {\n          const offset = addr - 0xA000;\n          if (offset < bank.length) {\n            bank[offset] = val;\n          }\n        } else {\n          console.log(`WARN in Mem.writeByte: External RAM bank ${this.cerb} not available`);\n        }\n      } else {\n        console.log(`WARN in Mem.writeByte: Attempt to write to non-existent external RAM bank at ${addr.toString(16)}`);\n      }\n    } else if (addr >= 0xC000 && addr < 0xE000) {\n      // Write to work RAM\n      const offset = addr - 0xC000;\n      if (offset < this.wram.length) {\n        this.wram[offset] = val;\n      }\n    } else if (addr >= 0xE000 && addr < 0xFE00) {\n      // Write to Echo RAM\n      console.log(`WARN in Mem.writeByte: Wrote to 'Echo Ram' at addr ${addr.toString(16)}`);\n      const offset = addr - 0xE000;\n      if (offset < this.wram.length) {\n        this.wram[offset] = val;\n      }\n    } else if (addr >= 0xFE00 && addr < 0xFEA0) {\n      // Write to Object Attribute Memory\n      const offset = addr - 0xFE00;\n      if (offset < this.oam.length) {\n        this.oam[offset] = val;\n      }\n    } else if (addr >= 0xFEA0 && addr < 0xFF00) {\n      // (Attempt to) write to Unusable Memory\n      console.log(`Error in Mem.writeByte: Attempt to write to unusable memory at addr ${addr.toString(16)}`);\n    } else if (addr >= 0xFF00 && addr < 0xFF80) {\n      // Write to I/O Registers\n      // TODO -- special behavior here\n      console.log(`TODO in Mem.writeByte: Write to I/O at ${addr.toString(16)}`);\n      const offset = addr - 0xFF00;\n      if (offset < this.io.length) {\n        this.io[offset] = val;\n      }\n    } else if (addr >= 0xFF80 && addr < 0xFFFF) {\n      // Write to High RAM\n      const offset = addr - 0xFF80;\n      if (offset < this.hram.length) {\n        this.hram[offset] = val;\n      }\n    } else if (addr === 0xFFFF) {\n      // Write to Interrupt Enable Register\n      this.ie[0] = val;\n    } else {\n      console.log(`Error in Mem.writeByte: Attempted to write outside memory map at ${addr.toString(16)}`);\n    }\n  }\n\n  readWord(addr: Address): UInt16 {\n    const low = this.readByte(addr);\n    const high = this.readByte((addr + 1) as Address);\n    return (high << 8) | low; // Little-endian\n  }\n\n  writeWord(addr: Address, val: UInt16): void {\n    this.writeByte(addr, val & 0xFF);\n    this.writeByte((addr + 1) as Address, (val >> 8) & 0xFF);\n  }\n}",
    "/**\n * Models the state and behavior of the Gameboy's CPU\n */\n\nimport { Mem } from './mem.js';\nimport { UInt8, UInt16, Address, Reg8, Reg16, CpuFlag } from './types.js';\n\ninterface Registers8 {\n  a: UInt8;\n  b: UInt8;\n  c: UInt8;\n  d: UInt8;\n  e: UInt8;\n  h: UInt8;\n  l: UInt8;\n  f: UInt8;\n}\n\ninterface CpuFlags {\n  // Bit 7 -- Zero Flag\n  z: boolean;\n  // Bit 6 -- Subtraction Flag (BCD)\n  n: boolean;\n  // Bit 5 -- Half Carry flag (BCD)\n  h: boolean;\n  // Big 4 -- Carry flag\n  c: boolean;\n}\n\nexport class CPU {\n  // Initalize 8-bit registers\n  private r: Registers8;\n  // Initalize special 16-bit registers\n  private sp: UInt16;\n  private pc: UInt16;\n  // Flags, contained within the lower eight bits of the af register\n  // In essense, the 'f' register is where these are stored\n  private flags: CpuFlags;\n  // The memory associated with the CPU\n  private mem: Mem;\n\n  constructor(mem: Mem) {\n    // Initalize 8-bit registers\n    this.r = {\n      a: 0x00,\n      b: 0x00,\n      c: 0x00,\n      d: 0x00,\n      e: 0x00,\n      h: 0x00,\n      l: 0x00,\n      f: 0x00\n    };\n    // Initalize special 16-bit registers\n    this.sp = 0x00;\n    this.pc = 0x00;\n\n    // Flags, contained within the lower eight bits of the af register\n    // In essense, the 'f' register is where these are stored\n    this.flags = {\n      // Bit 7 -- Zero Flag\n      z: false,\n      // Bit 6 -- Subtraction Flag (BCD)\n      n: false,\n      // Bit 5 -- Half Carry flag (BCD)\n      h: false,\n      // Big 4 -- Carry flag\n      c: false\n    };\n\n    // The memory associated with the CPU\n    this.mem = mem;\n  }\n\n  // Set the value of register 'reg' to 'val'\n  setr(reg: Reg8 | Reg16, val: UInt8 | UInt16): void {\n    // Todo -- maybe apply a warning here where there's an attempt to store values greater\n    // than 8/16 bits?\n\n    // NOTE -- accepts 16-bit values in BIG ENDIAN format!\n    // So if ('bc', 0xAFCD) is passed as val, 0xAFCD is going straight into r.bc\n    // When storing (little-endian) values from memory in 16-bit registers, make sure\n    // to swap them from little-to-big-endian first\n\n    if (reg in this.r && reg !== 'f') {\n      this.r[reg as Reg8] = (val & 0xFF) as UInt8;\n    } else if (['bc', 'de', 'hl', 'af'].includes(reg)) {\n      const reg16 = reg as Reg16;\n      // set Hi value\n      this.r[reg16[0] as Reg8] = ((val & 0xFFFF) >> 8) as UInt8;\n      // set Lo value\n      this.r[reg16[1] as Reg8] = (val & 0xFF) as UInt8;\n\n      // If the af register is the one being set, make sure flags are handled\n      if (reg === 'af') {\n        this.flags.z = Boolean(this.r.f & 0b10000000);\n        this.flags.n = Boolean(this.r.f & 0b01000000);\n        this.flags.h = Boolean(this.r.f & 0b00100000);\n        this.flags.c = Boolean(this.r.f & 0b00010000);\n        // Make sure bottom 4 bits are zero'd out\n        this.r.f = (this.r.f & 0b11110000) as UInt8;\n      }\n    } else if (['sp', 'pc'].includes(reg)) {\n      (this as any)[reg] = (val & 0xFFFF) as UInt16;\n    } else {\n      console.log(`Error in CPU.setr: invalid register ${reg}`);\n    }\n  }\n\n  // Get the value of 'reg'\n  getr(reg: Reg8 | Reg16): UInt8 | UInt16 | null {\n    if (reg in this.r && reg !== 'f') {\n      return this.r[reg as Reg8];\n    } else if (['bc', 'de', 'hl', 'af'].includes(reg)) {\n      const reg16 = reg as Reg16;\n      const hi = this.r[reg16[0] as Reg8];\n      const lo = this.r[reg16[1] as Reg8];\n      if (reg === 'af') {\n        // Zero out the bottom four bits of af just in case\n        // in hardware, these always read as zero\n        return (hi << 8 | (lo & 0b11110000)) as UInt16;\n      } else {\n        // otherwise return the combination of hi and lo\n        return (hi << 8 | lo) as UInt16;\n      }\n    } else if (['sp', 'pc'].includes(reg)) {\n      return (this as any)[reg] as UInt16;\n    } else {\n      console.log(`Error in CPU.getr: invalid register ${reg}`);\n      return null;\n    }\n  }\n\n  // Set specific flag\n  setf(flag: CpuFlag, val: boolean): UInt8 | null {\n    // check that paramters are valid and update appropriate flag\n    if (['z', 'n', 'h', 'c'].includes(flag) && typeof val === \"boolean\") {\n      if (flag === 'z') {\n        this.flags.z = val;\n      } else if (flag === 'n') {\n        this.flags.n = val;\n      } else if (flag === 'h') {\n        this.flags.h = val;\n      } else if (flag === 'c') {\n        this.flags.c = val;\n      }\n    } else {\n      console.log(`Error in CPU.setf: invalid parameter(s): flag ${flag}, val ${val}`);\n      return null;\n    }\n    // update value of f register based on flag in question\n    // z = bit 7\n    // n = bit 6\n    // h = bit 5\n    // c = bit 4\n    // bits 0-3 are always set to 0\n    let newf = 0b00000000;\n    if (this.flags.z) {\n      newf = newf | 0b10000000;\n    }\n    if (this.flags.n) {\n      newf = newf | 0b01000000;\n    }\n    if (this.flags.h) {\n      newf = newf | 0b00100000;\n    }\n    if (this.flags.c) {\n      newf = newf | 0b00010000;\n    }\n    this.r.f = newf as UInt8;\n\n    return newf as UInt8;\n  }\n\n  // Increment the stack pointer by a number of bytes\n  inc_pc(bytes: number): void {\n    this.pc = (this.pc + bytes) as UInt16;\n  }\n\n  // Grab the byte of data immediately following the program counter\n  imm8(): UInt8 {\n    return this.mem.readByte((this.getr('pc') as UInt16 + 1) as Address);\n  }\n\n  // Grab the two bytes of data immediately following the program counter (they are little-endian in memory)\n  imm16(): UInt16 {\n    const pc = this.getr('pc') as UInt16;\n    return (this.mem.readByte((pc + 2) as Address) << 8 | this.mem.readByte((pc + 1) as Address)) as UInt16;\n  }\n\n  // Add (or subtract) 8-bit values against each other\n  add8(a: UInt8, b: UInt8, sub: boolean = false): UInt8 {\n    let raw_result = 0;\n    if (sub) {\n      raw_result = a - b;\n    } else {\n      raw_result = a + b;\n    }\n    const trim_result = (raw_result & 0xFF) as UInt8;\n\n    // manage carry flag\n    if (raw_result > 0xFF || (sub && a < b)) {\n      this.setf('c', true);\n    } else {\n      this.setf('c', false);\n    }\n\n    // manage half carry flag\n    if (sub) {\n      if ((b & 0xF) > (a & 0xF)) {\n        this.setf('h', true);\n      } else {\n        this.setf('h', false);\n      }\n    } else {\n      if ((a & 0xF) + (b & 0xF) > 0xF) {\n        this.setf('h', true);\n      } else {\n        this.setf('h', false);\n      }\n    }\n\n    // manage zero flag\n    if (trim_result === 0) {\n      this.setf('z', true);\n    } else {\n      this.setf('z', false);\n    }\n\n    // manage subtraction flag\n    if (sub) {\n      this.setf('n', true);\n    } else {\n      this.setf('n', false);\n    }\n\n    return trim_result;\n  }\n\n  // Add (or subtract) 16-bit values against each other\n  add16(a: UInt16, b: UInt16, sub: boolean = false): UInt16 {\n    let raw_result = 0;\n    if (sub) {\n      raw_result = a - b;\n    } else {\n      raw_result = a + b;\n    }\n    const trim_result = (raw_result & 0xFFFF) as UInt16;\n\n    // manage carry flag\n    if (raw_result > 0xFFFF || (sub && a < b)) {\n      this.setf('c', true);\n    } else {\n      this.setf('c', false);\n    }\n\n    // manage half carry flag (for 16-bit operations, this is bit 11)\n    if (sub) {\n      if ((b & 0xFFF) > (a & 0xFFF)) {\n        this.setf('h', true);\n      } else {\n        this.setf('h', false);\n      }\n    } else {\n      if ((a & 0xFFF) + (b & 0xFFF) > 0xFFF) {\n        this.setf('h', true);\n      } else {\n        this.setf('h', false);\n      }\n    }\n\n    // manage zero flag\n    if (trim_result === 0) {\n      this.setf('z', true);\n    } else {\n      this.setf('z', false);\n    }\n\n    // manage subtraction flag\n    if (sub) {\n      this.setf('n', true);\n    } else {\n      this.setf('n', false);\n    }\n\n    return trim_result;\n  }\n\n  // Add a signed 8-bit value to a 16-bit value\n  add16_signed8(a16: UInt16, b8: UInt8): UInt16 {\n    // here, b8 is interpreted as SIGNED\n    // adding an 8-bit value to a 16-bit value doesn't naturally wrap\n    // after clamping the way adding two values of the same size do\n    // consider how 0xFF could be +255 (unsigned) or -1 (signed)\n    // if we add it to 0x0002 (16-bit 2):\n    //   0x0002 + 255 = 0x0101 -> clamp w/ & 0xFFFF = 0x0101\n    //   0x0002 -   1 = 0x0001 -> clamp w/ & 0xFFFF = 0x0001\n    // These don't match!\n    // now consider this case, where we add it to 0x02 (8-bit 2):\n    //   0x02 + 255 = 0x101    -> clamp w/ & 0xFF = 0x01\n    //   0x02 -   1 = 0x01     -> clamp w/ & 0xFF = 0x01\n    // When adding an 8-bit number to a 16-bit number, the overflow occurs\n    // at bit 15, not bit 7. This means we need to manually account for \n    // if we're interpreting the value as signed or unsigned in a way that\n    // is automatically handled by our clamping when adding 8-bit to 8-bit\n    let b8_signed: number;\n    if (b8 > 127) {\n      b8_signed = b8 - 256;\n    } else {\n      b8_signed = b8;\n    }\n    const raw_result = a16 + b8_signed;\n    const trim_result = (raw_result & 0xFFFF) as UInt16;\n\n    //however, all the flag logic still considers b8 as unsigned\n    // manage carry flag based on low byte addition\n    if (((a16 & 0xFF) + b8) > 0xFF) {\n      this.setf('c', true);\n    } else {\n      this.setf('c', false);\n    }\n\n    // manage half carry flag\n    if ((a16 & 0xF) + (b8 & 0xF) > 0xF) {\n      this.setf('h', true);\n    } else {\n      this.setf('h', false);\n    }\n\n    // Always clear the z and n flags\n    this.setf('z', false);\n    this.setf('n', false);\n\n    return trim_result;\n  }\n\n  // ----------------\n  // CPU INSTRUCTIONS\n  // ----------------\n  // All instructions return the duration in machine cycles\n\n  // -----------------------\n  // 8-BIT LOAD INSTRUCTIONS\n  // -----------------------\n  // Load TO r8_1 FROM r8_2\n  ld_r8_r8(r8_1: Reg8, r8_2: Reg8): number {\n    this.setr(r8_1, this.getr(r8_2) as UInt8);\n    this.inc_pc(1);\n    return 1;\n  }\n\n  // Load TO r8 FROM immediate byte\n  ld_r8_imm8(r8: Reg8): number {\n    this.setr(r8, this.imm8());\n    this.inc_pc(2);\n    return 2;\n  }\n\n  // Load TO r8 FROM data at absolute address specified by r16\n  ld_r8_r16ptr(r8: Reg8, r16ptr: Reg16): number {\n    this.setr(r8, this.mem.readByte(this.getr(r16ptr) as Address));\n    this.inc_pc(1);\n    return 2;\n  }\n\n  // Load TO data at absolute address specified by r16 FROM r8\n  ld_r16ptr_r8(r16ptr: Reg16, r8: Reg8): number {\n    this.mem.writeByte(this.getr(r16ptr) as Address, this.getr(r8) as UInt8);\n    this.inc_pc(1);\n    return 2;\n  }\n\n  // Load TO data at absolute address specified by r16ptr FROM immediate byte\n  ld_r16ptr_imm8(r16ptr: Reg16): number {\n    this.mem.writeByte(this.getr(r16ptr) as Address, this.imm8());\n    this.inc_pc(2);\n    return 3;\n  }\n\n  // Load TO r8 FROM data at absolute address specified by immediate two bytes\n  ld_r8_imm16ptr(r8: Reg8): number {\n    this.setr(r8, this.mem.readByte(this.imm16() as Address));\n    this.inc_pc(3);\n    return 4;\n  }\n\n  // Load TO data at absolute address specified by immediate two bytes FROM r8\n  ld_imm16ptr_r8(r8: Reg8): number {\n    this.mem.writeByte(this.imm16() as Address, this.getr(r8) as UInt8);\n    this.inc_pc(3);\n    return 4;\n  }\n\n  // Load TO a FROM data at absolute address specified by register C + 0xFF00\n  ld_a_ffcptr(): number {\n    this.setr('a', this.mem.readByte((this.getr('c') as UInt8 + 0xFF00) as Address));\n    this.inc_pc(1);\n    return 2;\n  }\n\n  // Load TO data at absolute address specified by register C + 0xFF00 FROM a\n  ld_ffcptr_a(): number {\n    this.mem.writeByte((this.getr('c') as UInt8 + 0xFF00) as Address, this.getr('a') as UInt8);\n    this.inc_pc(1);\n    return 2;\n  }\n\n  // Load TO a FROM data at absolute address specified by immediate byte + 0xFF00\n  ld_a_ffimm8ptr(): number {\n    this.setr('a', this.mem.readByte((this.imm8() + 0xFF00) as Address));\n    this.inc_pc(2);\n    return 3;\n  }\n\n  // Load TO data at absolute address specified by immediate byte + 0xFF00 FROM a\n  ld_ffimm8ptr_a(): number {\n    this.mem.writeByte((this.imm8() + 0xFF00) as Address, this.getr('a') as UInt8);\n    this.inc_pc(2);\n    return 3;\n  }\n\n  // Load TO a FROM data at absolute address specified by hl\n  // Decrement hl\n  ld_a_hl_dec(): number {\n    // current hl as of the time execution of this operation begins\n    const cur_hl = this.getr('hl') as UInt16;\n    this.setr('a', this.mem.readByte(cur_hl as Address));\n    // decrement hl with 16-bit wrap-around using bitwise and\n    this.setr('hl', (cur_hl - 1) & 0xFFFF);\n    this.inc_pc(1);\n    return 2;\n  }\n\n  // Load TO data at absolute address specified by hl FROM a\n  // Decrement hl\n  ld_hl_a_dec(): number {\n    // current hl as of the time execution of this operation begins\n    const cur_hl = this.getr('hl') as UInt16;\n    this.mem.writeByte(cur_hl as Address, this.getr('a') as UInt8);\n    // decrement hl with 16-bit wrap-around using bitwise and\n    this.setr('hl', (cur_hl - 1) & 0xFFFF);\n    this.inc_pc(1);\n    return 2;\n  }\n\n  // Load TO a FROM data at absolute address specified by hl\n  // Increment hl\n  ld_a_hl_inc(): number {\n    // current hl as of the time execution of this operation begins\n    const cur_hl = this.getr('hl') as UInt16;\n    this.setr('a', this.mem.readByte(cur_hl as Address));\n    // increment hl with 16-bit wrap-around using bitwise and\n    this.setr('hl', (cur_hl + 1) & 0xFFFF);\n    this.inc_pc(1);\n    return 2;\n  }\n\n  // Load TO data at absolute address specified by hl FROM a\n  // Increment hl\n  ld_hl_a_inc(): number {\n    // current hl as of the time execution of this operation begins\n    const cur_hl = this.getr('hl') as UInt16;\n    this.mem.writeByte(cur_hl as Address, this.getr('a') as UInt8);\n    // increment hl with 16-bit wrap-around using bitwise and\n    this.setr('hl', (cur_hl + 1) & 0xFFFF);\n    this.inc_pc(1);\n    return 2;\n  }\n\n  // -----------------------\n  // 16-BIT LOAD INSTUCTIONS\n  // -----------------------\n  // Load TO r16 FROM immediate two bytes\n  ld_r16_imm16(r16: Reg16): number {\n    this.setr(r16, this.imm16());\n    this.inc_pc(3);\n    return 3;\n  }\n\n  // Load TO the data at absolute address specified by immediate two bytes FROM sp\n  ld_imm16ptr_sp(): number {\n    this.mem.writeByte(this.imm16() as Address, this.sp);\n    this.inc_pc(3);\n    return 5;\n  }\n\n  // Load TO sp FROM hl\n  ld_sp_hl(): number {\n    this.sp = this.getr('hl') as UInt16;\n    this.inc_pc(1);\n    return 2;\n  }\n\n  // Push TO stack memory FROM r16\n  push_r16(r16: Reg16): number {\n    // current sp as of the time execution of this operation begins\n    const cur_sp = this.sp;\n    // words in memory are stored little-endian; the least significant byte is first\n    // registers are big-endian; the most significant byte is first\n    // grab the msb and lsb from r16\n    const r16_val = this.getr(r16) as UInt16;\n    const r16_msb = (r16_val & 0xFF00) >> 8;\n    const r16_lsb = (r16_val) & 0xFF;\n\n    // write the msb first (at a higher position in memory)\n    this.mem.writeByte(((cur_sp - 1) & 0xFFFF) as Address, r16_msb as UInt8);\n    // write the lsb second (at a lower position in memory)\n    // being at a lower position, it comes 'first' in memory -- little-endian\n    this.mem.writeByte(((cur_sp - 2) & 0xFFFF) as Address, r16_lsb as UInt8);\n\n    // set the sp to its new value\n    this.sp = ((cur_sp - 2) & 0xFFFF) as UInt16;\n    this.inc_pc(1);\n    return 4;\n  }\n\n  // Pop TO r16 FROM stack memory\n  pop_r16(r16: Reg16): number {\n    // current sp as of the time execution of this operation begins\n    const cur_sp = this.sp;\n\n    // words in memory are stored little-endian; the least significant byte is first\n    // registers are big-endian; the most significant byte is first\n    // since r16 is denoted by a string, we can index is to grab its constituent 8-bit registers\n    // then set them accordingly (lsb from earlier in memory, msb from later in memory)\n    this.setr(r16[0] as Reg8, this.mem.readByte(((cur_sp + 1) & 0xFFFF) as Address)); // set msb\n    this.setr(r16[1] as Reg8, this.mem.readByte(cur_sp as Address)); // set lsb\n\n    //set the sp to its new value\n    this.sp = ((cur_sp + 2) & 0xFFFF) as UInt16;\n\n    // while 'pop af' completely re-writes the f register, flag updates are handled in setr\n    this.inc_pc(1);\n    return 3;\n  }\n\n  // Load TO hl FROM adjusted sp\n  ld_hl_sp_plus_e(): number {\n    // 'adjusted sp' refers to sp plus signed imm8\n    const adj_sp = this.add16_signed8(this.sp, this.imm8());\n    this.setr('hl', adj_sp);\n    this.inc_pc(2);\n    return 3;\n  }\n} ",
    "// Import the file system module\nimport fs from 'fs';\nimport { Address } from './types.js';\n\ninterface RegisterMap {\n  [key: number]: string;\n}\n\ninterface ConditionMap {\n  [key: number]: string;\n}\n\nexport function readROM(filename: string): Uint8Array {\n  try {\n    // Read the file synchronously as a buffer (array of bytes)\n    return fs.readFileSync(filename);\n  } catch (error) {\n    console.error(`Error reading file: ${(error as Error).message}`);\n    process.exit(1);\n  }\n}\n\nfunction grab8BitArg(rom: Uint8Array, addr: Address): string {\n  if (addr + 1 < rom.length) {\n    return \"$\" + (rom[addr + 1] as number).toString(16).padStart(2, '0').toUpperCase();\n  } else {\n    console.error(\"Error: tried to fetch out-of-bounds argument\");\n    process.exit(1);\n  }\n}\n\nfunction grab16BitArg(rom: Uint8Array, addr: Address): string {\n  if (addr + 2 < rom.length) {\n    return \"$\" + ((rom[addr + 1] as number) | (rom[addr + 2] as number) << 8).toString(16).padStart(4, '0').toUpperCase();\n  } else {\n    console.error(\"Error: tried to fetch out-of-bounds argument\");\n    process.exit(1)\n  }\n}\n\nfunction disassemble(rom: Uint8Array, startAddr: Address, length: number): void {\n  let addr = startAddr\n  const endAddr = startAddr + length;\n  const instructions: string[] = [];\n\n  while (addr < endAddr) {\n    const [instruction, bytes] = decodeOpcode(rom, addr);\n    instructions.push(instruction);\n    addr += bytes;\n  }\n\n  console.log(\"completed disassembly\");\n  for (let i = 0; i < instructions.length; i++) {\n    console.log(instructions[i]);\n  }\n}\n\nexport function disassembleInstruction(rom: Uint8Array, addr: Address): { instruction: string; bytes: number } {\n  const [instruction, bytes] = decodeOpcode(rom, addr);\n  return { instruction, bytes };\n}\n\n// Many opcodes vary only in register paramters\n// Within these opcodes registers in question are denoted by the associated value\nconst r8: RegisterMap = {\n  0b000: \"B\",\n  0b001: \"C\",\n  0b010: \"D\",\n  0b011: \"E\",\n  0b100: \"H\",\n  0b101: \"L\",\n  0b110: \"[HL]\",\n  0b111: \"A\"\n};\n\nconst r16: RegisterMap = {\n  0b000: \"BC\",\n  0b001: \"DE\",\n  0b010: \"HL\",\n  0b011: \"SP\",\n};\n\nconst r16stk: RegisterMap = {\n  0b000: \"BC\",\n  0b001: \"DE\",\n  0b010: \"HL\",\n  0b011: \"AF\",\n};\n\nconst r16mem: RegisterMap = {\n  0b000: \"BC\",\n  0b001: \"DE\",\n  0b010: \"HL+\",\n  0b011: \"HL-\",\n};\n\nconst cond: ConditionMap = {\n  0b000: \"NZ\",\n  0b001: \"Z\",\n  0b010: \"NC\",\n  0b011: \"C\"\n};\n\nfunction decodeOpcode(rom: Uint8Array, addr: Address): [string, number] {\n  // Assume the instruction has no additional data bytes after the opcode until shown \n  // otherwise\n  let bytes = 1;\n\n  // Grab the opcode \n  let opcode = rom[addr] as number;\n\n  // By default, we don't know what this is\n  let instruction = `***ILLEGAL INSTRUCTION***: $${opcode.toString(16).padStart(2, '0').toUpperCase()}`;\n\n  // Grab some bit patterns from within the opcode\n  // At some point I might want better names for these \n  // 11000000\n  const pat1 = (opcode & 0b11000000) >> 6;\n\n  // 00110000\n  const pat2 = (opcode & 0b00110000) >> 4;\n\n  // 00111000\n  const pat3 = (opcode & 0b00111000) >> 3;\n\n  // 00011000\n  const pat4 = (opcode & 0b00011000) >> 3;\n\n  // 00000111\n  const pat5 = (opcode & 0b00000111);\n\n  // 00001111\n  const pat6 = (opcode & 0b00001111);\n\n  // 00111111\n  const pat7 = (opcode & 0b00111111);\n\n  // Process CB opcodes\n  if (opcode == 0xCB) {\n    console.log(\"CB opcodes -- todo!\")\n    instruction = \"--CB PLACEHOLDER--\";\n\n    // All CB-opcode instructions are two bytes\n    // The first is the CB prefix, the second actually details the behavior\n    // in this sense, the second 'is' the opcode, rather than a conventional argument\n    bytes += 1\n\n    if (addr + 1 < rom.length) {\n      opcode = rom[addr + 1] as number\n      switch (pat1) {\n        case 0b00:\n          switch (pat3) {\n            case 0b000:\n              instruction = `RLC ${r8[pat5]}`;\n              break;\n            case 0b001:\n              instruction = `RRC ${r8[pat5]}`;\n              break;\n            case 0b010:\n              instruction = `RL ${r8[pat5]}`;\n              break;\n            case 0b011:\n              instruction = `RR ${r8[pat5]}`;\n              break;\n            case 0b100:\n              instruction = `SLA ${r8[pat5]}`;\n              break;\n            case 0b101:\n              instruction = `SRA ${r8[pat5]}`;\n              break;\n            case 0b110:\n              instruction = `SWAP ${r8[pat5]}`;\n              break;\n            case 0b111:\n              instruction = `SRL ${r8[pat5]}`;\n              break;\n          }\n          break;\n        case 0b01:\n          instruction = `BIT $${pat3.toString(16).padStart(2, '0')}, ${r8[pat5]}`;\n          break;\n        case 0b10:\n          instruction = `RES $${pat3.toString(16).padStart(2, '0')}, ${r8[pat5]}`;\n          break;\n        case 0b11:\n          instruction = `SET $${pat3.toString(16).padStart(2, '0')}, ${r8[pat5]}`;\n          break;\n      }\n    } else {\n      console.error(\"Error: tried to fetch out-of-bounds followup to CB opcode\");\n      process.exit(1);\n    }\n\n    // Process non-CB opcodes\n  } else {\n\n    // Switch statment for first two bits\n    switch (pat1) {\n      // Case for first two bits 00\n      case 0b00:\n        // Switch on first-two 00 opcodes distinguished by last four bits\n        switch (pat6) {\n          case 0b0000:\n            instruction = \"NOP\";\n            break;\n          case 0b0001:\n            bytes += 2;\n            instruction = `LD ${r16[pat2]}, ${grab16BitArg(rom, addr)}`;\n            break;\n          case 0b0010:\n            instruction = `LD ${r16mem[pat2]}, A`;\n            break;\n          case 0b1010:\n            instruction = `LD A, ${r16mem[pat2]}`;\n            break;\n          case 0b1000:\n            bytes += 2;\n            instruction = `LD ${grab16BitArg(rom, addr)}, SP`;\n            break;\n          case 0b0011:\n            instruction = `INC ${r16[pat2]}`;\n            break;\n          case 0b1011:\n            instruction = `DEC ${r16[pat2]}`;\n            break;\n          case 0b1001:\n            instruction = `ADD HL, ${r16[pat2]}`;\n            break;\n\n          // Now handle the first-two 00 opcodes distinguished by the last three bits\n          default:\n            switch (pat5) {\n              case 0b100:\n                instruction = `INC ${r8[pat2]}`;\n                break;\n              case 0b101:\n                instruction = `DEC ${r8[pat2]}`;\n                break;\n              case 0b110:\n                bytes += 1;\n                instruction = `LD ${r8[pat2]}, ${grab8BitArg(rom, addr)}`;\n                break;\n              case 0b111:\n                // Eight unique single-instruction opcodes make up the first-two\n                // 00 AND last-three 000 opcodes\n                switch (pat3) {\n                  case 0b000:\n                    instruction = \"RLCA\";\n                    break;\n                  case 0b001:\n                    instruction = \"RRCA\";\n                    break;\n                  case 0b010:\n                    instruction = \"RLA\";\n                    break;\n                  case 0b011:\n                    instruction = \"RRA\";\n                    break;\n                  case 0b100:\n                    instruction = \"DAA\";\n                    break;\n                  case 0b101:\n                    instruction = \"CPL\";\n                    break;\n                  case 0b110:\n                    instruction = \"SCF\";\n                    break;\n                  case 0b111:\n                    instruction = \"CCF\";\n                    break;\n                }\n                break;\n              case 0b000:\n                switch (pat3) {\n                  case 0b011:\n                    bytes += 1\n                    instruction = `JR ${grab8BitArg(rom, addr)}`;\n                    break;\n                  case 0b010:\n                    instruction = \"STOP\";\n                    break;\n                }\n                break;\n            }\n            break;\n        }\n        break;\n\n      // Case for first two bits 01\n      case 0b01:\n        // Halt instruction is a unqiue case of the 8-bit register-to-register load\n        // Specifically, LD [HL], [HL]\n        if (opcode == 0b01110110) {\n          instruction = \"HALT\";\n        } else {\n          instruction = `LD ${r8[pat3]}, ${r8[pat5]}`;\n        }\n        break;\n\n      // Case for first two bits 10\n      case 0b10:\n        // All of this is 8-bit arithmetic, split on pat3\n        switch (pat3) {\n          case 0b000:\n            instruction = `ADD A, ${r8[pat5]}`;\n            break\n          case 0b001:\n            instruction = `ADC A, ${r8[pat5]}`;\n            break;\n          case 0b010:\n            instruction = `SUB A, ${r8[pat5]}`;\n            break;\n          case 0b011:\n            instruction = `SBC A, ${r8[pat5]}`;\n            break;\n          case 0b100:\n            instruction = `AND A, ${r8[pat5]}`;\n            break;\n          case 0b101:\n            instruction = `XOR A, ${r8[pat5]}`;\n            break;\n          case 0b110:\n            instruction = `OR A, ${r8[pat5]}`;\n            break;\n          case 0b111:\n            instruction = `CP A, ${r8[pat5]}`;\n            break;\n        }\n        break;\n\n      // Case for first two bits on 11\n      case 0b11:\n        // First-two 11, last-three 110 instructions are all 8-bit arithmetic between\n        // a register and an argument\n        if (pat5 == 0b110) {\n          switch (pat3) {\n            case 0b000:\n              bytes += 1;\n              instruction = `ADD A, ${grab8BitArg(rom, addr)}`;\n              break;\n            case 0b001:\n              bytes += 1;\n              instruction = `ADC A, ${grab8BitArg(rom, addr)}`;\n              break;\n            case 0b010:\n              bytes += 1;\n              instruction = `SUB A, ${grab8BitArg(rom, addr)}`;\n              break;\n            case 0b011:\n              bytes += 1;\n              instruction = `SBC A, ${grab8BitArg(rom, addr)}`;\n              break;\n            case 0b100:\n              bytes += 1;\n              instruction = `AND A, ${grab8BitArg(rom, addr)}`;\n              break;\n            case 0b101:\n              bytes += 1;\n              instruction = `XOR A, ${grab8BitArg(rom, addr)}`;\n              break;\n            case 0b110:\n              bytes += 1;\n              instruction = `OR A, ${grab8BitArg(rom, addr)}`;\n              break;\n            case 0b111:\n              bytes += 1;\n              instruction = `CP A, ${grab8BitArg(rom, addr)}`;\n              break;\n          }\n        } else {\n          // Many one-off unique opcodes here, and few that use reg bit patterns\n          // We'll do all the one-offs, then handle the patterns in the default case\n          //\n          // This particular organization probably makes sense for the disassembler\n          // but might be worth revisiting when developing the emulator\n          switch (pat7) {\n            case 0b001001:\n              instruction = \"RET\";\n              break;\n            case 0b011001:\n              instruction = \"RETI\";\n              break;\n            case 0b000011:\n              bytes += 2;\n              instruction = `JP ${grab16BitArg(rom, addr)}`;\n              break;\n            case 0b101001:\n              instruction = `JP HL`;\n              break;\n            case 0b11001101:\n              bytes += 2\n              instruction = `CALL ${grab16BitArg(rom, addr)}`;\n              break;\n            case 0b100010:\n              instruction = `LDH [${r8[0b001]}], A`;\n              break;\n            case 0b100000:\n              bytes += 1;\n              instruction = `LDH [${grab8BitArg(rom, addr)}], A`;\n              break;\n            case 0b101010:\n              bytes += 2;\n              instruction = `LD [${grab16BitArg(rom, addr)}], A`;\n              break;\n            case 0b110010:\n              bytes += 2;\n              instruction = `LDH A, [${r8[0b001]}]`;\n              break;\n            case 0b110000:\n              bytes += 1;\n              instruction = `LDH A, [${grab8BitArg(rom, addr)}]`;\n              break;\n            case 0b111010:\n              bytes += 2;\n              instruction = `LD A, [${grab16BitArg(rom, addr)}]`;\n              break;\n            case 0b101000:\n              bytes += 1;\n              instruction = `ADD SP, ${grab8BitArg(rom, addr)}`;\n              break;\n            case 0b111000:\n              bytes += 1;\n              instruction = `LD HL, SP + ${grab8BitArg(rom, addr)}`;\n              break;\n            case 0b111001:\n              instruction = `LD SP, HL`;\n              break;\n            case 0b110011:\n              instruction = \"DI\"\n              break;\n            case 0b111011:\n              instruction = \"EI\"\n              break;\n\n            default:\n              switch (pat5) {\n                case 0b000:\n                  instruction = `RET ${cond[pat4]}`;\n                  break;\n                case 0b010:\n                  bytes += 2;\n                  instruction = `JP ${cond[pat4]}, ${grab16BitArg(rom, addr)}`\n                  break;\n                case 0b100:\n                  bytes += 2;\n                  instruction = `CALL ${cond[pat4]}, ${grab16BitArg(rom, addr)}`\n                  break;\n                case 0b111:\n                  instruction = `RST ${(8 * pat3).toString(16).padStart(2, \"0\")}`;\n                  break;\n                case 0b001:\n                  instruction = `POP ${r16stk[pat2]}`;\n                  break;\n                case 0b101:\n                  instruction = `PUSH ${r16stk[pat2]}`;\n                  break;\n              }\n              break;\n          }\n        }\n        break;\n    }\n  }\n  return [instruction, bytes];\n}\n\n// Main execution - only run if this file is executed directly\n// Check if we're being run directly vs imported\nif (process.argv[1] && process.argv[1].endsWith('disasm.ts') || process.argv[1] && process.argv[1].endsWith('disasm.js')) {\n  // Check if we have enough command line arguments\n  if (process.argv.length < 3) {\n    console.log('Usage: node disasm.js <rom-file> [start-address] [length]');\n    process.exit(1);\n  }\n\n  // Get the ROM filename from command line arguments\n  const romFile = process.argv[2];\n  // Get the start address (optional, default to 0)\n  const startAddr = process.argv[3] ? parseInt(process.argv[3], 16) : 0;\n  // Get optional length (default 100 bytes)\n  const length = process.argv[4] ? parseInt(process.argv[4], 16) : 0x100;\n\n  if (romFile) {\n    try {\n      const rom = readROM(romFile);\n      disassemble(rom, startAddr as Address, length);\n    } catch (error) {\n      console.error(`Error: ${(error as Error).message}`);\n      process.exit(1);\n    }\n  }\n}\n",
    "/**\n * Models the GameBoy as a whole from its constituent parts\n */\n\nimport { Mem } from './mem.js';\nimport { CPU } from './cpu.js';\nimport { disassembleInstruction } from './disasm.js';\nimport { Address, UInt16 } from './types.js';\n\nexport class GB {\n  private mem: Mem;\n  private cpu: CPU;\n\n  constructor(rom?: Uint8Array) {\n    this.mem = new Mem(rom);\n    this.cpu = new CPU(this.mem);\n  }\n\n  // TODO: Add methods to run the emulator\n  public run(): void {\n    console.log('GameBoy emulator running...');\n    // TODO: Implement main emulation loop\n  }\n\n  public step(): void {\n    // Execute one CPU instruction\n    const pc = this.cpu.getr('pc') as UInt16;\n    // TODO: Fetch instruction, decode, execute\n    console.log(`PC: 0x${pc.toString(16).padStart(4, '0')}`);\n  }\n\n  public disassembleAtPC(): string {\n    const pc = this.cpu.getr('pc') as UInt16;\n    const rom = new Uint8Array(0x8000); // Placeholder - should get from memory\n    // TODO: Read from actual ROM data\n    const result = disassembleInstruction(rom, pc as Address);\n    return result.instruction;\n  }\n\n  public getMem(): Mem {\n    return this.mem;\n  }\n\n  public getCPU(): CPU {\n    return this.cpu;\n  }\n\n  public reset(): void {\n    // Reset CPU to initial state\n    this.cpu.setr('pc', 0x0100); // Game Boy starts at 0x0100\n    this.cpu.setr('sp', 0xFFFE);\n    this.cpu.setr('af', 0x01B0);\n    this.cpu.setr('bc', 0x0013);\n    this.cpu.setr('de', 0x00D8);\n    this.cpu.setr('hl', 0x014D);\n  }\n}",
    "import { Mem } from './mem.js';\nimport { CPU } from './cpu.js';\nimport { GB } from './gb.js';\n// import { disassemble, readROM } from './disasm.js'; // Available if needed\nimport { UInt8, UInt16, Address } from './types.js';\n\n/**\n * Game Boy Emulator Entry Point\n */\nfunction main(): void {\n  console.log('🎮 Game Boy Emulator Starting...');\n\n  // Test memory system\n  console.log('\\n--- Testing Memory System ---');\n  testMemorySystem();\n\n  // Test CPU system\n  console.log('\\n--- Testing CPU System ---');\n  testCPUSystem();\n\n  // Test full Game Boy system\n  console.log('\\n--- Testing Full Game Boy System ---');\n  testGameBoySystem();\n\n  console.log('\\n✅ All systems operational!');\n}\n\nfunction testMemorySystem(): void {\n  const memory = new Mem();\n\n  // Test basic memory operations\n  const testAddr: Address = 0x8000;\n  const testValue: UInt8 = 0xFF;\n\n  try {\n    memory.writeByte(testAddr, testValue);\n    const readValue = memory.readByte(testAddr);\n\n    console.log(`Memory test: wrote 0x${testValue.toString(16)}, read 0x${readValue.toString(16)}`);\n\n    if (readValue === testValue) {\n      console.log('✅ Basic memory operations working');\n    } else {\n      console.log('❌ Memory test failed');\n    }\n\n    // Test word operations\n    const wordAddr: Address = 0x8100;\n    const wordValue: UInt16 = 0x1234;\n\n    memory.writeWord(wordAddr, wordValue);\n    const readWord = memory.readWord(wordAddr);\n\n    console.log(`Word test: wrote 0x${wordValue.toString(16)}, read 0x${readWord.toString(16)}`);\n\n    if (readWord === wordValue) {\n      console.log('✅ Word operations working');\n    } else {\n      console.log('❌ Word test failed');\n    }\n\n  } catch (error) {\n    console.error('❌ Error during memory tests:', error);\n  }\n}\n\nfunction testCPUSystem(): void {\n  const memory = new Mem();\n  const cpu = new CPU(memory);\n\n  try {\n    // Test register operations\n    cpu.setr('a', 0x42);\n    cpu.setr('bc', 0x1234);\n\n    const regA = cpu.getr('a') as UInt8;\n    const regBC = cpu.getr('bc') as UInt16;\n\n    console.log(`CPU register test: A=0x${regA.toString(16)}, BC=0x${regBC.toString(16)}`);\n\n    if (regA === 0x42 && regBC === 0x1234) {\n      console.log('✅ CPU register operations working');\n    } else {\n      console.log('❌ CPU register test failed');\n    }\n\n    // Test flag operations\n    cpu.setf('z', true);\n    cpu.setf('c', false);\n\n    console.log('✅ CPU flag operations working');\n\n    // Test arithmetic\n    const result = cpu.add8(0x10, 0x20);\n    console.log(`CPU arithmetic test: 0x10 + 0x20 = 0x${result.toString(16)}`);\n\n    if (result === 0x30) {\n      console.log('✅ CPU arithmetic working');\n    } else {\n      console.log('❌ CPU arithmetic test failed');\n    }\n\n  } catch (error) {\n    console.error('❌ Error during CPU tests:', error);\n  }\n}\n\nfunction testGameBoySystem(): void {\n  try {\n    const gameboy = new GB();\n\n    // Reset to known state\n    gameboy.reset();\n\n    const cpu = gameboy.getCPU();\n    const pc = cpu.getr('pc') as UInt16;\n    const sp = cpu.getr('sp') as UInt16;\n\n    console.log(`Game Boy initialized: PC=0x${pc.toString(16)}, SP=0x${sp.toString(16)}`);\n\n    if (pc === 0x0100 && sp === 0xFFFE) {\n      console.log('✅ Game Boy system initialization working');\n    } else {\n      console.log('❌ Game Boy initialization test failed');\n    }\n\n    // Test disassembly (with dummy data)\n    const instruction = gameboy.disassembleAtPC();\n    console.log(`Disassembly at PC: ${instruction}`);\n    console.log('✅ Disassembler integration working');\n\n  } catch (error) {\n    console.error('❌ Error during Game Boy tests:', error);\n  }\n}\n\n// Run the emulator\nmain();"
  ],
  "mappings": "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",
  "debugId": "AD4FB59149EF5BA264756E2164756E21",
  "names": []
}